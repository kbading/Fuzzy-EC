---
title: "Data wrangling and cleaning -- WSW study program test | first, incomplete, version"
author: "Karoline Bading // Jérémy Béna"
date: $26^{th}$ of January 2023
output:
  html_document:
    toc: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, comment = NA)
```

# Set-up

## Call packages

```{r packages}
#Data wrangling and cleaning

#Load (or install and load) packages
require(pacman)
p_load('tidyverse', 'jsonlite', 'psych', 'readbulk')
```

## Read the data

I performed the test in "local" lab.js (I exported the lab.js study program for offline data collection) -- if we collect data this way, we will have one .csv file for each participant. So, first, we need to retrieve and merge all the .csv (for the example here, I did two runs).

```{r read_data, message=FALSE, warning=FALSE}
dat = read_bulk("C:/Users/benaj/OneDrive - UCL/Postdoctorat/projects_Karoline/study/test_study/test_data/") #will need to change the directory

# # Read the text file from JATOS (first batch)...
# read_file('jatos_results_20220630194157_firstbatch.txt')%>%
# #... split it into lines ...
#  str_split('\n') %>% first() %>%
# #... filter empty rows ...
#  discard(function(x) x == '') %>%
# #... parse JSON into a data.frame
#  map_dfr(fromJSON, flatten=T) -> dat
```

# Data cleaning and wrangling

## Data cleaning

The dataset `dat` we now have contains a lot of columns we do not need, so we will select only the useful columns. In addition, some useful information (e.g., whether a participant declared they were serious) is only available in one row, which is problematic to, e.g., exclude such a participant -- so we repeat `age`, `gender`, `serious`, and `pay_attention` on each row of each participant. 

```{r data_cleaning}
table(dat$pay_attention) #X participants declared they did not pay attention -- we will exclude them in another .Rmd?
table(dat$serious) #X participants declared they provided non-serious responses -- we will exclude them in another .Rmd?

table(dat$gender)

table(dat$age) #maybe rework the trial to allow only for numeric responses

#add participant number
##find where data of a new participant appears (i.e., when "sender" == "consent")
n_ppt = which(dat$sender=="consent")

#add this information in a "ppt" column
dat$ppt = NA
dat$ppt[n_ppt] = 1:length(n_ppt)
                      
#repeat ppt, age, gender, pay attention, and serious on every line of each participant; then select only useful variables
dat = dat %>%
   fill(ppt, .direction = "down") %>% 
  group_by(ppt) %>% 
  fill(consent, serious, pay_attention, age, gender, .direction = "down") %>%
  fill(serious, pay_attention, age, gender, .direction = "up") %>% 
  select(ppt, sender, duration, ended_on, age, gender, serious, pay_attention, response, response_action #general information
         , count_trial_learning, cs, cs_category, us,us_valence, uss #learning phase
         , count_trial_memory, idtarg, reco_resp, source_mem  #memory phase
         , count_trial_ratings, cs_rating #rating phase 
         ) 

```

## Make the final dataset

In the experiment, there were three main tasks (learning phase; source memory task; rating task). For each task, we create a dataset to select the critical information and rearrange the data if necessary. The main idea is to create a final dataset with 48 (24 CSs paired with USs in the learning phase + 24 new neutral stimuli) * N_participants rows. At each CS*Participant level, all responses provided by the participants will be available (e.g., for a given CS and participant, the recognition, CS-US pairing memory, and rating responses).

### Learning phase

Besides making a dataset for the learning phase, we tested whether 24 US and 24 unique CS-US pairs displayed six times each for each participant. 

```{r learning}
#learning phase
#keep only the rows of the conditioning phase trials
dat_learning = dat %>% filter(sender == "learning_trial")  %>%
  select(ppt, count_trial_learning, cs, cs_category, us,us_valence, uss)

#check if we have all the different USs (24) across participants 
length(unique(dat_learning$us)) #we have

#check if, for each participant, all USs were used
count_us = unique(dat_learning[,c('ppt','us')])

dat_count_us = count_us %>%                           
  group_by(ppt) %>%
  summarise(count = n_distinct(us))

table(dat_count_us$count==24) #yes

#check if for each participant, all different CSs were used
count_cs = unique(dat_learning[,c('ppt','cs')])

#count if we have only 24 unique cs-us pairs between participants
count_pairings = unique(dat_learning[,c('ppt','cs','us')])
count_pairings$cs_us = paste0(count_pairings$cs, count_pairings$us)

count_pairings %>%                           
 group_by(ppt) %>%
  summarise(count = n_distinct(cs_us))
#seems ok! 24 unique CS-US pairs
```

### Memory task

```{r memory}
dat_reco = dat %>% filter(sender=="recognition_trial") %>%
  select(ppt, count_trial_memory, cs, cs_category, us, us_valence, uss, idtarg, reco_resp)

dat_source = dat %>% filter(sender=="source_trial") %>%
  select(ppt, count_trial_memory, cs, cs_category, us, us_valence, uss, idtarg, source_mem)
```

### Ratings

```{r ratings}
dat_ratings = dat %>% filter(sender=="rating_trial") %>%
  select(ppt, count_trial_ratings, cs, cs_category, us, us_valence, cs_rating)
```

### Put the memory and rating datasets together

We don't need the `dat_learning` dataset as the relevant information it contains also appears in the other datasets (specifically, the `cs`, `us`, `uss`, `idtarg` variables).

```{r make_dataset}
#make the final data set -- based on multiple "full_join" to integrate all conditions and responses based on ppts, cs, us

#join recognition and source memory responses 
dat_mem = full_join(dat_reco, dat_source,
                               , by = c("ppt"="ppt", "cs" = "cs", "us"="us", "uss"="uss", "idtarg"="idtarg", "cs_category"="cs_category", "us_valence"="us_valence", "count_trial_memory"="count_trial_memory"))

#join memory dataset and rating dataset
dat_final = full_join(dat_mem, dat_ratings
                               , by = c("ppt"="ppt", "cs" = "cs", "us"="us","cs_category"="cs_category", "us_valence"="us_valence"))
```

# Write the final dataset (for use in the analysis `.Rmd`)

```{r write_data}
#write the final dataset we will use for analyses in another R script
saveRDS(dat_final, "data_wsw_final.RDS") #RDS can handle lists such as in the `uss` list
```

# To do list

+ check whether same number of old/new CSs, male and female CSs, male old, male new, female old, female new CSs
+ check whether each CS condition is associated with the same number of positive and negative USs
+ check whether we can identify the correct US in the "source memory" task (I think we do, with `idtarg` and `uss`) -- I think I have some R code for this from a previous study, I will check
+ ???